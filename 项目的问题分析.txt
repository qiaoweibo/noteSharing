org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper@1a562d3a（struts:request）
org.apache.catalina.connector.RequestFacade@7e10c67a(servlet:request)


1.在servlet中实现：可以接受表单提交过来的数据，如何实现web.xml中servlet和action的配置的共存问题
2.在action中如何实现让“request”和servlet中的“request”一致，

3.在表单中一旦定义了enctype="multipart/form-data"，其他的值就无法通过request传到后台了



System.out.println(request);
System.out.println(factory);
System.out.println(path);
System.out.println(upload);
System.out.println(list);
问题出在struts中的list为空：主要原因还是两种方式中的request不同
            List<FileItem> list = (List<FileItem>)upload.parseRequest(request);  

struts:
已接收到请求
org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper@2882cd1a
org.apache.commons.fileupload.disk.DiskFileItemFactory@5fdd98f8
C:\Java EE\apache-tomcat-7.0.77\webapps\TestDemo\images
org.apache.commons.fileupload.servlet.ServletFileUpload@3e983cec
[]

servlet:
已接收到请求
org.apache.catalina.connector.RequestFacade@21e57cd
org.apache.commons.fileupload.disk.DiskFileItemFactory@37113aa5
C:\Java EE\apache-tomcat-7.0.77\webapps\TestDemo\images
org.apache.commons.fileupload.servlet.ServletFileUpload@23207d1c

[name=C:\Users\Administrator\Desktop\61224-106.jpg, StoreLocation=C:\Java EE\apache-tomcat-7.0.77\webapps\TestDemo\images\upload_4ac9d4dc_4f29_47a6_a58c_cff436a9195e_00000000.tmp, size=457451 bytes, isFormField=false, FieldName=upload, name=null, StoreLocation=C:\Java EE\apache-tomcat-7.0.77\webapps\TestDemo\images\upload_4ac9d4dc_4f29_47a6_a58c_cff436a9195e_00000001.tmp, size=0 bytes, isFormField=true, FieldName=username, name=null, StoreLocation=C:\Java EE\apache-tomcat-7.0.77\webapps\TestDemo\images\upload_4ac9d4dc_4f29_47a6_a58c_cff436a9195e_00000002.tmp, size=0 bytes, isFormField=true, FieldName=detaildescription]



修改密码：
异常：
在插入时:
org.hibernate.StaleStateException: Batch update returned unexpected row count from update: 0 actual row count: 0 expected: 1
表单中：
<input type="text" name="sid" value='<s:property value="#session.modify_students.sid"/>'  readonly="readonly"/>是因为慕课上是将信息保存到session中（它的查找和修改都用到了session）

。。。。。。首先在updatepassword()方法中。获取。数据库中该用户实体，才能修改，再存入数据库
Hibernate: 
    update
        USERS 
    set
        USERNAME=?,
        PASSWORD=?,
        GENDER=?,
        PHONE=?,
        HEADPORTRAIT=? 
    where
        UID=?



复合主键的设置
<hibernate-mapping>
    <class name="com.suxiaolei.hibernate.pojos.People" table="people">        <!-- 复合主键使用composite-id标签 -->        <composite-id>            <!-- key-property标签表示哪一些属性对应复合主键 -->
            <key-property name="id" column="id" type="string"></key-property>
            <key-property name="name" column="name" type="string"></key-property>
    	</composite-id>        
    	<property name="age" column="age" type="integer"></property>
    </class>
</hibernate-mapping>



create table upload 
( 
	 imageid int,
   username varchar(255), 
   uid int, 
   upa varchar(255), 
	 detaildescription varchar(255),
	 label1 varchar(255),
	 label2 varchar(255),
	 label3 varchar(255),
   primary key (imageid,uid) 
) 


<hibernate-mapping>
    <class name="entity.Upload" table="UPLOAD">
        <id name="imageId" type="integer">
            <column name="IMAGEID" />
            <generator class="identity" />
            <!--<generator class="identity" /> 主键设置为自增长 -->
            <!-- <generator class="increment"/> 取最大值加一 -->
        </id>
        <!--
        <id name="uid" type="integer">
        	<column name="UID"/>
        	<generator class="increment"/>
        </id>
         -->
        <property name="uid" type="int">
            <column name="UID" />
        </property> 
        <property name="upa" type="java.lang.String">
            <column name="UPA" />
        </property>
        <property name="detaildescription" type="java.lang.String">
            <column name="DETAILDESCRIPTION" />
        </property>
        <property name="label1" type="java.lang.String">
            <column name="LABEL1" />
        </property>
        <property name="label2" type="java.lang.String">
            <column name="LABEL2" />
        </property>
        <property name="label3" type="java.lang.String">
            <column name="LABEL3" />
        </property>
        <property name="username" type="java.lang.String">
            <column name="USERNAME" />
        </property>
    </class>
</hibernate-mapping>




/*实体类，使用复合主键必须实现Serializable接口*/
public class People implements Serializable{
   private static final long serialVersionUID = -4888836126783955019L;
   private String id;
   private String name;
   private int age;
      public People()
   {      
    }
   public String getId()
   {       
return id;
   }
   public void setId(String id)
   {       
this.id = id;
   }
   public String getName()
   {       
return name;
   }   
public void setName(String name)
   {       
this.name = name;
   }   
public int getAge()
   {       return age;   }
   public void setAge(int age)
   {       this.age = age;   }
   @Override   public int hashCode()
   {       final int prime = 31;
       int result = 1;
       result = prime * result + ((id == null) ? 0 : id.hashCode());
       result = prime * result + ((name == null) ? 0 : name.hashCode());
       return result;
   }
   @Override
   public boolean equals(Object obj)
   {       if (this == obj)
           return true;
       if (obj == null)
           return false;
       if (getClass() != obj.getClass())
           return false;
       People other = (People) obj;
       if (id == null)
       {           if (other.id != null)
               return false;       } 
      else if (!id.equals(other.id))
           return false;
       if (name == null)
       {           if (other.name != null) 
              return false;       } 
      else if (!name.equals(other.name)) 
          return false;       return true;   }

}





怎么设置imageId随着imageSetId的改变而从1开始自增长

复合主键中应该不可以使用<generator class="increment"/>，因为generator并不是key-property的子元素。但具体没试过，应该不行，没那么神奇吧。

这里想modelid自增就是为了保持主键的唯一性，因为一样的typeid和producerid可能对应多个modelid。

可以这么解决，在保存之前，在取出typeid，producerid对应的modelid最大的值，不妨设为lastModelId，然后将要保存的对象的modelid设置为lastModelId+1,然后save